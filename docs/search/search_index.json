{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"tutorials/adb/","text":"adb (Android Debug Bridge) adb ist ein Kommandozeilenprogramm mit dem unterschiedliche Aufgaben auf einem verkn\u00fcpften Android Ger\u00e4t ausgef\u00fchrt werden k\u00f6nnen. Am verkn\u00fcpfen Android Ger\u00e4t l\u00e4uft ein Dienst (Daemon) adbd , welcher \u00fcber das Kommandozeilenprogramm adb auf dem Entwicklungsrechner angesprochen werden kann. Mit der Installation von Android Studio wird adb am Entwicklungsrechner installiert und kann \u00fcber die Kommandozeile genutzt werden. Beispiele Verkn\u00fcpfte Ger\u00e4te auflisten > adb devices Daten auf das Ger\u00e4t laden (push) > adb push C:\\lokale-datei.txt /sdcard/pushedfile.txt Daten vom Ger\u00e4t herunterladen (pull) > adb pull /sdcard/remotefile.txt C:\\lokale-remote-datei.txt Shell \u00dcber adb kann man sich auf die Linux-Shell des Android-Ger\u00e4ts einloggen. > adb shell Impliziten Intent starten > adb shell > am start -a android.intent.action.SENDTO -d sms:+43234235235 -e sms_body \"hello world\" Screenshot machen und herunterladen > adb shell > screencap /sdcard/screenshot.png > exit > adb pull /sdcard/screenshot.png ./screenshot.png","title":"adb"},{"location":"tutorials/adb/#adb-android-debug-bridge","text":"adb ist ein Kommandozeilenprogramm mit dem unterschiedliche Aufgaben auf einem verkn\u00fcpften Android Ger\u00e4t ausgef\u00fchrt werden k\u00f6nnen. Am verkn\u00fcpfen Android Ger\u00e4t l\u00e4uft ein Dienst (Daemon) adbd , welcher \u00fcber das Kommandozeilenprogramm adb auf dem Entwicklungsrechner angesprochen werden kann. Mit der Installation von Android Studio wird adb am Entwicklungsrechner installiert und kann \u00fcber die Kommandozeile genutzt werden.","title":"adb (Android Debug Bridge)"},{"location":"tutorials/adb/#beispiele","text":"","title":"Beispiele"},{"location":"tutorials/adb/#verknupfte-gerate-auflisten","text":"> adb devices","title":"Verkn\u00fcpfte Ger\u00e4te auflisten"},{"location":"tutorials/adb/#daten-auf-das-gerat-laden-push","text":"> adb push C:\\lokale-datei.txt /sdcard/pushedfile.txt","title":"Daten auf das Ger\u00e4t laden (push)"},{"location":"tutorials/adb/#daten-vom-gerat-herunterladen-pull","text":"> adb pull /sdcard/remotefile.txt C:\\lokale-remote-datei.txt","title":"Daten vom Ger\u00e4t herunterladen (pull)"},{"location":"tutorials/adb/#shell","text":"\u00dcber adb kann man sich auf die Linux-Shell des Android-Ger\u00e4ts einloggen. > adb shell","title":"Shell"},{"location":"tutorials/adb/#impliziten-intent-starten","text":"> adb shell > am start -a android.intent.action.SENDTO -d sms:+43234235235 -e sms_body \"hello world\"","title":"Impliziten Intent starten"},{"location":"tutorials/adb/#screenshot-machen-und-herunterladen","text":"> adb shell > screencap /sdcard/screenshot.png > exit > adb pull /sdcard/screenshot.png ./screenshot.png","title":"Screenshot machen und herunterladen"},{"location":"tutorials/apps-ausf%C3%BChren/","text":"Apps ausf\u00fchren Um ein App Projekt, welches \u00fcber Android Studio ge\u00f6ffnet wurde, auszuf\u00fchren bestehen generell 2 M\u00f6glichkeiten. Entweder kann das Projekt innerhalb eines Emulators ausgef\u00fchrt werden oder auf einem Android Ger\u00e4t das \u00fcber USB oder Wifi mit dem Entwicklungsrechner verkn\u00fcpft ist. Verf\u00fcgbare Ger\u00e4te werden im Dropdown neben dem Play-Button angezeigt. Nach Auswahl eines entsprechenden Ger\u00e4tes kann die App darauf gestartet werden (Klick auf den Play-Button). Emulator Der Emulator simuliert ein echtes Android Ger\u00e4t und bietet nahezu alle Funktionen, welche auch ein richtiges Android Ger\u00e4t bietet. Als System-Vorausetzung um Emulatoren zu nutzen muss Intel\u00ae HAXM installiert werden. Download von Intel\u00ae HAXM Troubleshooting Intel\u00ae HAXM Troubleshooting von Android Der Erstellung und Verwendung von Emulatoren ist grunds\u00e4tzlich sehr intuitiv und ben\u00f6tigt wenig Erkl\u00e4rung. Alle Details zu Emulatoren finden sich in der Android Dokumentation ( Emulatoren ). Android Ger\u00e4t Die Ausf\u00fchrung der App ist am Android Smartphone oft schneller und einfacher als am Emulator. Damit ein Smartphone zur Ausf\u00fchrung von Apps in Entwicklung verwendet werden kann, m\u00fcssen die Entwickleroptionen freigeschalten werden: Entwickleroptionen freischalten Dazu muss am Android Smartphone in Einstellungen > Telefoninfo nach der Buildnummer gesucht werden. Diese findet sich zB unter Einstellungen > Telefoninfo > Softwareinformationen . Es muss dann ca. 7-mal auf die Buildnummer geklickt werden, dann werden die Entwickleroptionen freigeschalten. USB-Debugging aktivieren Nachdem die Entwickleroptionen freigeschalten wurden, finden sich diese unter Einstellungen > Entwickleroptionen . Dort muss USB-Debugging aktiviert werden und das Smartphone muss \u00fcber USB-Kabel am Rechner angeschlossen sein.","title":"Apps ausf\u00fchren"},{"location":"tutorials/apps-ausf%C3%BChren/#apps-ausfuhren","text":"Um ein App Projekt, welches \u00fcber Android Studio ge\u00f6ffnet wurde, auszuf\u00fchren bestehen generell 2 M\u00f6glichkeiten. Entweder kann das Projekt innerhalb eines Emulators ausgef\u00fchrt werden oder auf einem Android Ger\u00e4t das \u00fcber USB oder Wifi mit dem Entwicklungsrechner verkn\u00fcpft ist. Verf\u00fcgbare Ger\u00e4te werden im Dropdown neben dem Play-Button angezeigt. Nach Auswahl eines entsprechenden Ger\u00e4tes kann die App darauf gestartet werden (Klick auf den Play-Button).","title":"Apps ausf\u00fchren"},{"location":"tutorials/apps-ausf%C3%BChren/#emulator","text":"Der Emulator simuliert ein echtes Android Ger\u00e4t und bietet nahezu alle Funktionen, welche auch ein richtiges Android Ger\u00e4t bietet. Als System-Vorausetzung um Emulatoren zu nutzen muss Intel\u00ae HAXM installiert werden. Download von Intel\u00ae HAXM Troubleshooting Intel\u00ae HAXM Troubleshooting von Android Der Erstellung und Verwendung von Emulatoren ist grunds\u00e4tzlich sehr intuitiv und ben\u00f6tigt wenig Erkl\u00e4rung. Alle Details zu Emulatoren finden sich in der Android Dokumentation ( Emulatoren ).","title":"Emulator"},{"location":"tutorials/apps-ausf%C3%BChren/#android-gerat","text":"Die Ausf\u00fchrung der App ist am Android Smartphone oft schneller und einfacher als am Emulator. Damit ein Smartphone zur Ausf\u00fchrung von Apps in Entwicklung verwendet werden kann, m\u00fcssen die Entwickleroptionen freigeschalten werden:","title":"Android Ger\u00e4t"},{"location":"tutorials/apps-ausf%C3%BChren/#entwickleroptionen-freischalten","text":"Dazu muss am Android Smartphone in Einstellungen > Telefoninfo nach der Buildnummer gesucht werden. Diese findet sich zB unter Einstellungen > Telefoninfo > Softwareinformationen . Es muss dann ca. 7-mal auf die Buildnummer geklickt werden, dann werden die Entwickleroptionen freigeschalten.","title":"Entwickleroptionen freischalten"},{"location":"tutorials/apps-ausf%C3%BChren/#usb-debugging-aktivieren","text":"Nachdem die Entwickleroptionen freigeschalten wurden, finden sich diese unter Einstellungen > Entwickleroptionen . Dort muss USB-Debugging aktiviert werden und das Smartphone muss \u00fcber USB-Kabel am Rechner angeschlossen sein.","title":"USB-Debugging aktivieren"},{"location":"tutorials/neues-projekt/","text":"Neues Projekt erstellen \u00dcber den Projekt-Wizard wird man durch den Erstellungsprozess eines neues Android Projektes geleitet. Neues Projekt Nachdem ersten Start von Android Studio ist die Ansicht, wie unten im Screenshot dargestellt, vorhanden. Dabei kann \u00fcber Klick auf + Start a new Android Studio project ein neues Projekt erstellt werden. Alternativ kann \u00fcber die ge\u00f6ffnete Android Studio Projektansicht \u00fcber das Men\u00fc File > New > New Project... ein neues Projekt erstellt werden. Erste Activity w\u00e4hlen Mit dem Projekt-Wizard k\u00f6nnen Android Projekte f\u00fcr die Plattformen Phone and Tablet , Wear OS , TV , Automotive und Android Things erstellt werden. Unser Fokus liegt dabei auf Phone and Tablet . Ein Android Projekt besteht normalerweise zumindest aus einer Activity. Ein gro\u00dfes Android Projekt kann durchaus \u00fcber Hundert Activities umfassen. F\u00fcr ein neues Projekt kann aus unterschiedlichen Templates f\u00fcr die erste Activity gew\u00e4hlt werden. F\u00fcr die meisten unserer Projekte w\u00e4hlen wir das Template Empty Activity . Projektkonfiguration Projektkonfiguration Im letzten Schritt des Projekt-Wizard werden wichtige Daten zum Projekt festgelegt. All diese Daten k\u00f6nnen grunds\u00e4tzlich sp\u00e4ter noch ver\u00e4ndert werden, dies ist dann aber teilweise mit aufw\u00e4ndigen Refactoring verbunden. Folgende Parameter k\u00f6nnen festgelegt werden: Name: Der Name wird an allen wichtigen Stellen im Android Betriebssystem f\u00fcr die App angezeigt (zB am All-Apps Screen oder am Recents Screen). Package name: Alle Klassen des Projektes werden mit diesem Package Name versehen. Save location: An dieser Stelle wird das Projekt am Dateisystem gespeichert. Language: Native Android Apps k\u00f6nnen grunds\u00e4tzlich in Java oder Kotlin entwickelt werden. Minimum SDK: Auswahl der SDK Version die mindestens unterst\u00fctzt werden soll (siehe unten). Minimum SDK w\u00e4hlen F\u00fcr Android wird zumindest j\u00e4hrlich eine neue Version (inkl. SDK) ver\u00f6ffentlicht. Die Auswahl h\u00e4ngt davon ab, welche \u00e4lteren Android Versionen von der App noch unterst\u00fctzt werden sollen. Im Screenshot ist ersichtlich, dass neuere Android Versionen global eine sehr geringe Verbreitung haben. Das Ziel eines Projektes sollte grunds\u00e4tzlich sein, dass ein gro\u00dfe Zahl von Benutzern die App uneingeschr\u00e4nkt benutzen k\u00f6nnen. Eine Unterst\u00fctzung von mind. 80% ist in den meisten F\u00e4llen eine gute Wahl. Projekt erstellen W\u00e4hlen Sie die Parameter um Ihr geplantes Projekt zu erstellen und klicken Sie auf Finish .","title":"Neues Projekt"},{"location":"tutorials/neues-projekt/#neues-projekt-erstellen","text":"\u00dcber den Projekt-Wizard wird man durch den Erstellungsprozess eines neues Android Projektes geleitet.","title":"Neues Projekt erstellen"},{"location":"tutorials/neues-projekt/#neues-projekt","text":"Nachdem ersten Start von Android Studio ist die Ansicht, wie unten im Screenshot dargestellt, vorhanden. Dabei kann \u00fcber Klick auf + Start a new Android Studio project ein neues Projekt erstellt werden. Alternativ kann \u00fcber die ge\u00f6ffnete Android Studio Projektansicht \u00fcber das Men\u00fc File > New > New Project... ein neues Projekt erstellt werden.","title":"Neues Projekt"},{"location":"tutorials/neues-projekt/#erste-activity-wahlen","text":"Mit dem Projekt-Wizard k\u00f6nnen Android Projekte f\u00fcr die Plattformen Phone and Tablet , Wear OS , TV , Automotive und Android Things erstellt werden. Unser Fokus liegt dabei auf Phone and Tablet . Ein Android Projekt besteht normalerweise zumindest aus einer Activity. Ein gro\u00dfes Android Projekt kann durchaus \u00fcber Hundert Activities umfassen. F\u00fcr ein neues Projekt kann aus unterschiedlichen Templates f\u00fcr die erste Activity gew\u00e4hlt werden. F\u00fcr die meisten unserer Projekte w\u00e4hlen wir das Template Empty Activity . Projektkonfiguration","title":"Erste Activity w\u00e4hlen"},{"location":"tutorials/neues-projekt/#projektkonfiguration","text":"Im letzten Schritt des Projekt-Wizard werden wichtige Daten zum Projekt festgelegt. All diese Daten k\u00f6nnen grunds\u00e4tzlich sp\u00e4ter noch ver\u00e4ndert werden, dies ist dann aber teilweise mit aufw\u00e4ndigen Refactoring verbunden. Folgende Parameter k\u00f6nnen festgelegt werden: Name: Der Name wird an allen wichtigen Stellen im Android Betriebssystem f\u00fcr die App angezeigt (zB am All-Apps Screen oder am Recents Screen). Package name: Alle Klassen des Projektes werden mit diesem Package Name versehen. Save location: An dieser Stelle wird das Projekt am Dateisystem gespeichert. Language: Native Android Apps k\u00f6nnen grunds\u00e4tzlich in Java oder Kotlin entwickelt werden. Minimum SDK: Auswahl der SDK Version die mindestens unterst\u00fctzt werden soll (siehe unten).","title":"Projektkonfiguration"},{"location":"tutorials/neues-projekt/#minimum-sdk-wahlen","text":"F\u00fcr Android wird zumindest j\u00e4hrlich eine neue Version (inkl. SDK) ver\u00f6ffentlicht. Die Auswahl h\u00e4ngt davon ab, welche \u00e4lteren Android Versionen von der App noch unterst\u00fctzt werden sollen. Im Screenshot ist ersichtlich, dass neuere Android Versionen global eine sehr geringe Verbreitung haben. Das Ziel eines Projektes sollte grunds\u00e4tzlich sein, dass ein gro\u00dfe Zahl von Benutzern die App uneingeschr\u00e4nkt benutzen k\u00f6nnen. Eine Unterst\u00fctzung von mind. 80% ist in den meisten F\u00e4llen eine gute Wahl. Projekt erstellen W\u00e4hlen Sie die Parameter um Ihr geplantes Projekt zu erstellen und klicken Sie auf Finish .","title":"Minimum SDK w\u00e4hlen"},{"location":"%C3%BCbungen/01/","text":"\u00dcbungsblatt 1 \u00dcbung 0 Die Android Dokumentation stellt ein gut dokumentiertes Tutorial \"Build your first app\" bereit. Dieses Tutorial soll Schritt f\u00fcr Schritt durchgef\u00fchrt werden. \u00dcbung 1 (1,5h) Erstellen Sie eine neue App mit dem Namen \u201eSixteen Buttons\u201c. Diese App soll einen Screen besitzen und ein Layout. Das Layout soll dabei ein LinearLayout sein, welches programmatisch beim Start der Activity mit 16 Buttons bef\u00fcllt wird (siehe Screenshot). Wichtig zu beachten ist, dass das LinearLayout von einer ScrollView umgeben sein soll, sodass Buttons die nicht in den Screen passen durch Scrollen erreichbar sind. Die Buttons sollen mit dem Text Button 1 bis Button 16 beschriftet sein. Hinweis Die 16 Buttons sollen innerhalb einer Schleife in der Methode onCreate hinzugef\u00fcgt werden. Mit der Methode findViewById kann das LinearLayout im Java Code referenziert werden. Das LinearLayout erbt von ViewGroup und verf\u00fcgt deshalb \u00fcber die Methode addView . Mit der Methode addView k\u00f6nnen die Buttons dem Layout hinzugef\u00fcgt werden. \u00dcbung 2 (1,5h) Mit Klick auf einen der Buttons soll ein Toast abgesetzt werden. Der Inhalt des Toasts soll \"Klick auf Button x\" sein. Dabei soll der Platzhalter x mit der entsprechenden Nummerierung des Buttons ausgetauscht werden. Hierbei kann der Wert der Button Aufschrift genutzt werden, welche in \u00dcbung 1 gesetzt wurde. Mit der Methode getText der Klasse Button kann dieser Wert abgefragt werden. \u00dcbung 3 (3h) Das Projekt soll nun zu einem kleinen Spiel weiterentwickelt werden. Nach dem Zufallsprinzip soll ein Button aus der Liste ausgew\u00e4hlt werden und mit einer roten Schriftfarbe versehen werden. Nur beim Klick auf den Button mit der roten Schrift soll der Toast aus \u00dcbung 2 abgesetzt werden. Nachdem auf den Button mit roter Schrift geklickt wurde, soll wieder zu Schritt 1 \u00fcbergegangen werden und ein neuer zuf\u00e4lliger Button eine rote Schriftfarbe bekommen. Hinweis Das LinearLayout besitzt die Methoden getChildCount und getChildAt . Jedes Kind des LinearLayout kann \u00fcber einen Index abgefragt werden, die Indizes liegen dabei zwischen 0 und getChildCount - 1 (\u00e4hnlich wie bei Arrays). Mit der Methode setTextColor kann eine Farbe gesetzt werden. Mit der Methode getCurrentTextColor kann die aktuelle Farbe abgefragt werden. Mit statischen Methoden und Eigenschaften der Klasse Color k\u00f6nnen entsprechende Farbwerte erzeugt werden. \u00dcbung 4 (4h) Mit Klick auf den ersten Button mit roter Schrift soll ein Timestamp ( System.currentTimeMillis ) erstellt werden. Nachdem gesamt 5 Buttons mit roter Schrift geklickt wurden, soll die Zeitspanne seit dem ersten erfolgreichen Klick errechnet werden. Dannach soll eine weitere Activity ( GameOverActivity ), mittels Intent, gestartet werden und als Extra soll die Zeitspanne \u00fcbergeben werden. Die GameOverActivity soll folgendes Layout haben: Mit Klick auf den Button Neustart soll das Spiel \"Sixteen Buttons\" wieder gestartet werden. Wichtig ist dabei, dass der Timestamp bei Klick auf den ersten Button mit roter Schrift wieder zur\u00fcckgesetzt wird und das Spiel kann wieder gestartet werden. Hinweis Die Navigation zwischen den einzelnen Activities wird \u00fcber Intents durchgef\u00fchrt. Damit die jeweiligen Activities nicht mehrmals auf den Back Stack gelegt werden, sollten die Intents mit dem Flag FLAG_ACTIVITY_CLEAR_TOP versehen werden. Dazu soll die Methode addFlags verwendet werden. Das folgende Snippet soll dies veranschaulichen: Intent intent = new Intent(...); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); startActivity(intent);","title":"\u00dcbungsblatt 1"},{"location":"%C3%BCbungen/01/#ubungsblatt-1","text":"","title":"\u00dcbungsblatt 1"},{"location":"%C3%BCbungen/01/#ubung-0","text":"Die Android Dokumentation stellt ein gut dokumentiertes Tutorial \"Build your first app\" bereit. Dieses Tutorial soll Schritt f\u00fcr Schritt durchgef\u00fchrt werden.","title":"\u00dcbung 0"},{"location":"%C3%BCbungen/01/#ubung-1-15h","text":"Erstellen Sie eine neue App mit dem Namen \u201eSixteen Buttons\u201c. Diese App soll einen Screen besitzen und ein Layout. Das Layout soll dabei ein LinearLayout sein, welches programmatisch beim Start der Activity mit 16 Buttons bef\u00fcllt wird (siehe Screenshot). Wichtig zu beachten ist, dass das LinearLayout von einer ScrollView umgeben sein soll, sodass Buttons die nicht in den Screen passen durch Scrollen erreichbar sind. Die Buttons sollen mit dem Text Button 1 bis Button 16 beschriftet sein. Hinweis Die 16 Buttons sollen innerhalb einer Schleife in der Methode onCreate hinzugef\u00fcgt werden. Mit der Methode findViewById kann das LinearLayout im Java Code referenziert werden. Das LinearLayout erbt von ViewGroup und verf\u00fcgt deshalb \u00fcber die Methode addView . Mit der Methode addView k\u00f6nnen die Buttons dem Layout hinzugef\u00fcgt werden.","title":"\u00dcbung 1 (1,5h)"},{"location":"%C3%BCbungen/01/#ubung-2-15h","text":"Mit Klick auf einen der Buttons soll ein Toast abgesetzt werden. Der Inhalt des Toasts soll \"Klick auf Button x\" sein. Dabei soll der Platzhalter x mit der entsprechenden Nummerierung des Buttons ausgetauscht werden. Hierbei kann der Wert der Button Aufschrift genutzt werden, welche in \u00dcbung 1 gesetzt wurde. Mit der Methode getText der Klasse Button kann dieser Wert abgefragt werden.","title":"\u00dcbung 2 (1,5h)"},{"location":"%C3%BCbungen/01/#ubung-3-3h","text":"Das Projekt soll nun zu einem kleinen Spiel weiterentwickelt werden. Nach dem Zufallsprinzip soll ein Button aus der Liste ausgew\u00e4hlt werden und mit einer roten Schriftfarbe versehen werden. Nur beim Klick auf den Button mit der roten Schrift soll der Toast aus \u00dcbung 2 abgesetzt werden. Nachdem auf den Button mit roter Schrift geklickt wurde, soll wieder zu Schritt 1 \u00fcbergegangen werden und ein neuer zuf\u00e4lliger Button eine rote Schriftfarbe bekommen. Hinweis Das LinearLayout besitzt die Methoden getChildCount und getChildAt . Jedes Kind des LinearLayout kann \u00fcber einen Index abgefragt werden, die Indizes liegen dabei zwischen 0 und getChildCount - 1 (\u00e4hnlich wie bei Arrays). Mit der Methode setTextColor kann eine Farbe gesetzt werden. Mit der Methode getCurrentTextColor kann die aktuelle Farbe abgefragt werden. Mit statischen Methoden und Eigenschaften der Klasse Color k\u00f6nnen entsprechende Farbwerte erzeugt werden.","title":"\u00dcbung 3 (3h)"},{"location":"%C3%BCbungen/01/#ubung-4-4h","text":"Mit Klick auf den ersten Button mit roter Schrift soll ein Timestamp ( System.currentTimeMillis ) erstellt werden. Nachdem gesamt 5 Buttons mit roter Schrift geklickt wurden, soll die Zeitspanne seit dem ersten erfolgreichen Klick errechnet werden. Dannach soll eine weitere Activity ( GameOverActivity ), mittels Intent, gestartet werden und als Extra soll die Zeitspanne \u00fcbergeben werden. Die GameOverActivity soll folgendes Layout haben: Mit Klick auf den Button Neustart soll das Spiel \"Sixteen Buttons\" wieder gestartet werden. Wichtig ist dabei, dass der Timestamp bei Klick auf den ersten Button mit roter Schrift wieder zur\u00fcckgesetzt wird und das Spiel kann wieder gestartet werden. Hinweis Die Navigation zwischen den einzelnen Activities wird \u00fcber Intents durchgef\u00fchrt. Damit die jeweiligen Activities nicht mehrmals auf den Back Stack gelegt werden, sollten die Intents mit dem Flag FLAG_ACTIVITY_CLEAR_TOP versehen werden. Dazu soll die Methode addFlags verwendet werden. Das folgende Snippet soll dies veranschaulichen: Intent intent = new Intent(...); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); startActivity(intent);","title":"\u00dcbung 4 (4h)"},{"location":"%C3%BCbungen/02/","text":"\u00dcbungsblatt 2 \u00dcbung 0 In diesem \u00dcbungsblatt soll das Spiel \"Simon Game\" realisiert werden. Innerhalb der \u00dcbung 0 soll das Spiellayout erstellt werden. Dazu gibt es ein Videotutorial , welches befolgt werden soll. \u00c4nderungen im Video Anstelle des Button soll ein ImageButton verwendet werden. Der ImageButton hat das Attribut src . An dieses Attribut soll die Drawable Resource gesetzt werden. Der background des ImageButton soll mit dem Wert @android:color/transparent gesetzt werden. \u00dcbung 1 (2h) Die 4 Buttons des Spiels k\u00f6nnen innerhalb eines Arrays hinterlegt werden (als Eigentschaft der Activity), welches in der onCreate Methode initialisiert werden soll. Zus\u00e4tzlich soll eine Methode animateButtons erzeugt werden, welche eine Sequenz von Indizes (0 bis 3) f\u00fcr die einzelnen Buttons enth\u00e4lt. Die Indizes Sequenz soll nacheinander abgespielt werden. public void animateButtons ( int [] sequence ) { // Sequenzielles Blinken implementieren } Mit dem ObjectAnimator k\u00f6nnen die Buttons animiert werden und damit kann die Blinkeigenschaft des Spieles erzeugt werden. Das Blinken des Buttons soll \u00fcber die Animation des Alphawerts von 100% auf 60% gesetzt und wieder zur\u00fcck gesetzt werden. Die Instanzen der ObjectAnimator Klasse k\u00f6nnen als Array in ein AnimatorSet \u00fcber die Methode playSequentially hinzugef\u00fcgt werden. Das AnimatorSet kann dann \u00fcber die Methode start abgespielt werden. // Array von ObjectAnimator Instanzen erzeugen ObjectAnimator [] oas = new ObjectAnimator [ sequence . length ] ; // ObjectAnimator Instanzen erzeugen und im oas Array hinzuf\u00fcgen for ( int i = 0 ; i < oas . length ; i ++ ) { // oas[i] = ... } AnimatorSet am = new AnimatorSet (); // Array von ObjectAnimator Instanzen hinzuf\u00fcgen am . playSequentially ( oas ); // Alle ObjectAnimator Instanzen abspielen am . start (); Als Test soll in der Methode onCreate die Methode animateButtons mit einer Testsequenz aufgerufen werden. Zum Beispiel w\u00fcrde die folgende Sequenz die 4 Buttons nacheinander abspielen. animateButtons ( int [] { 0 , 1 , 2 , 3 }); \u00dcbung 2 (1h) Die Buttons des Spiels sollen mit einem View.OnTouchListener verkn\u00fcpft werden. Der View.OnTouchListener kann zum Beispiel direkt in der Activity implementiert werden. Beim Eintreten des Events ACTION_DOWN soll der Alphawert des Buttons auf 60% gesetzt werden. Beim Eintreten des Events ACTION_UP soll der Alphawert wieder auf 100% gesetzt werden. \u00dcbung 3 (3h) Die Sequenz, welche animiert werden soll, soll Schritt f\u00fcr Schritt \u00fcber eine Zufallszahl zwischen 0 und 3 erzeugt werden. Bei Start der App soll eine ArrayList (diese kann dynamisch erweitert werden) mit einem Zufallswert erstellt werden (zB [3]). Der Ablauf des Spiels soll dann folgenderma\u00dfen gestaltet sein: Abspielen der Sequenz \u00fcber die Methode animateButtons (\u00dcbung 1). W\u00e4hrend des Abspielen sollen die Buttons deaktiviert sein. Nach dem Abspielen sollten alle Buttons aktiviert sein und \u00fcber Touch-Events (\u00dcbung 2) Schritt f\u00fcr Schritt gepr\u00fcft werden ob die eingehenden Klicks in der Reichenfolge sind, wie gew\u00fcnscht in der generierten Sequenz. Falls die Sequenz von der Benutzerin richtig wiedergegeben wurde, soll eine neue Zufallszahl (zwischen 0 und 3) erzeugt werden und in der ArrayList hinzugef\u00fcgt werden. Danach soll wieder bei Schritt 1 gestartet werden. Falls die Sequenz von der Benutzerin nicht richtig wiedergegeben wurde, soll die L\u00e4nge der richtig gespielten Buttons \u00fcber ein Extra an eine GameOverActivity (\u00dcbung 4) \u00fcbergeben werden. Hinweis 1 Eine einfache M\u00f6glichkeit um eine ArrayList<Integer> in ein int[] Array zu \u00fcberf\u00fchren ist \u00fcber eine Schleife, wie im folgenden Snippet demonstriert: ArrayList<Integer> list = new ArrayList<>(); // ... Eintr\u00e4ge hinzuf\u00fcgen int sequence[] = new int[list.size()]; for (int i = 0; i < sequence.length; i++) { sequence[i] = list.get(i); } Hinweis 2 Buttons k\u00f6nnen \u00fcber die Methode setEnabled aktiviert oder deaktiviert werden. Hinweis 3 Auf das Ende der Animationssequenz des AnimatorSet kann \u00fcber einen Listener reagiert werden ( Dokumentation ). \u00dcbung 4 (2h) Es sollen 2 weitere Activities eingef\u00fchrt werden und die aktuelle MainActivity soll zu einer GameActivity refactored werden: Es soll eine neue MainActivity geben, welche 2 Buttons enth\u00e4lt, welche das Spiel entweder im Normalen Modus oder im Schnellen Modus starten k\u00f6nnen. \u00dcber ein Extra im Intent sollen unterschiedliche Werte f\u00fcr die Duration der Animationen \u00fcbergeben werden (eine schnelle und eine normale Variante). Die GameActivity soll das Spiel enthalten, also alles was von \u00dcbung 0 bis \u00dcbung 3 implementiert wurde. Die GameOverActivity soll die Anzahl der richtig gespielten Buttons anzeigen. \u00dcbung 5 (1h) F\u00fcr die 3 Buttons ( Normal Mode , Fast Mode und Restart ), die Textfelder und den Hintergrund sollen jeweils Variablen f\u00fcr die Farben bzw. Styles erstellt werden. Die Styles bzw. Farbvariablen sollen entsprechend mit den UI-Elementen verkn\u00fcpft werden. Folgend findet sich eine beispielhafte Angabe der Styles: <style name= \"Theme.SimonGame.GameButton\" parent= \"Widget.MaterialComponents.Button\" > <!-- items --> </style> <style name= \"Theme.SimonGame.GameText\" parent= \"Widget.MaterialComponents.TextView\" > <!-- items --> </style> \u00dcbung 6 (1h) F\u00fcr das Spiel soll es m\u00f6glich sein, dass zwischen einem normalen und einem dunklen Design gewechselt werden kann. Jenachdem welche Systemeinstellung die Benutzerin trifft, soll sich auch die App anpassen. Die entsprechenden Farbwerte, welche in \u00dcbung 5 definiert wurden, sollten \u00fcber den night Qualifier \u00fcberladen werden. Das rechte Bild zeigt das Spiel im normalen Design.","title":"\u00dcbungsblatt 2"},{"location":"%C3%BCbungen/02/#ubungsblatt-2","text":"","title":"\u00dcbungsblatt 2"},{"location":"%C3%BCbungen/02/#ubung-0","text":"In diesem \u00dcbungsblatt soll das Spiel \"Simon Game\" realisiert werden. Innerhalb der \u00dcbung 0 soll das Spiellayout erstellt werden. Dazu gibt es ein Videotutorial , welches befolgt werden soll. \u00c4nderungen im Video Anstelle des Button soll ein ImageButton verwendet werden. Der ImageButton hat das Attribut src . An dieses Attribut soll die Drawable Resource gesetzt werden. Der background des ImageButton soll mit dem Wert @android:color/transparent gesetzt werden.","title":"\u00dcbung 0"},{"location":"%C3%BCbungen/02/#ubung-1-2h","text":"Die 4 Buttons des Spiels k\u00f6nnen innerhalb eines Arrays hinterlegt werden (als Eigentschaft der Activity), welches in der onCreate Methode initialisiert werden soll. Zus\u00e4tzlich soll eine Methode animateButtons erzeugt werden, welche eine Sequenz von Indizes (0 bis 3) f\u00fcr die einzelnen Buttons enth\u00e4lt. Die Indizes Sequenz soll nacheinander abgespielt werden. public void animateButtons ( int [] sequence ) { // Sequenzielles Blinken implementieren } Mit dem ObjectAnimator k\u00f6nnen die Buttons animiert werden und damit kann die Blinkeigenschaft des Spieles erzeugt werden. Das Blinken des Buttons soll \u00fcber die Animation des Alphawerts von 100% auf 60% gesetzt und wieder zur\u00fcck gesetzt werden. Die Instanzen der ObjectAnimator Klasse k\u00f6nnen als Array in ein AnimatorSet \u00fcber die Methode playSequentially hinzugef\u00fcgt werden. Das AnimatorSet kann dann \u00fcber die Methode start abgespielt werden. // Array von ObjectAnimator Instanzen erzeugen ObjectAnimator [] oas = new ObjectAnimator [ sequence . length ] ; // ObjectAnimator Instanzen erzeugen und im oas Array hinzuf\u00fcgen for ( int i = 0 ; i < oas . length ; i ++ ) { // oas[i] = ... } AnimatorSet am = new AnimatorSet (); // Array von ObjectAnimator Instanzen hinzuf\u00fcgen am . playSequentially ( oas ); // Alle ObjectAnimator Instanzen abspielen am . start (); Als Test soll in der Methode onCreate die Methode animateButtons mit einer Testsequenz aufgerufen werden. Zum Beispiel w\u00fcrde die folgende Sequenz die 4 Buttons nacheinander abspielen. animateButtons ( int [] { 0 , 1 , 2 , 3 });","title":"\u00dcbung 1 (2h)"},{"location":"%C3%BCbungen/02/#ubung-2-1h","text":"Die Buttons des Spiels sollen mit einem View.OnTouchListener verkn\u00fcpft werden. Der View.OnTouchListener kann zum Beispiel direkt in der Activity implementiert werden. Beim Eintreten des Events ACTION_DOWN soll der Alphawert des Buttons auf 60% gesetzt werden. Beim Eintreten des Events ACTION_UP soll der Alphawert wieder auf 100% gesetzt werden.","title":"\u00dcbung 2 (1h)"},{"location":"%C3%BCbungen/02/#ubung-3-3h","text":"Die Sequenz, welche animiert werden soll, soll Schritt f\u00fcr Schritt \u00fcber eine Zufallszahl zwischen 0 und 3 erzeugt werden. Bei Start der App soll eine ArrayList (diese kann dynamisch erweitert werden) mit einem Zufallswert erstellt werden (zB [3]). Der Ablauf des Spiels soll dann folgenderma\u00dfen gestaltet sein: Abspielen der Sequenz \u00fcber die Methode animateButtons (\u00dcbung 1). W\u00e4hrend des Abspielen sollen die Buttons deaktiviert sein. Nach dem Abspielen sollten alle Buttons aktiviert sein und \u00fcber Touch-Events (\u00dcbung 2) Schritt f\u00fcr Schritt gepr\u00fcft werden ob die eingehenden Klicks in der Reichenfolge sind, wie gew\u00fcnscht in der generierten Sequenz. Falls die Sequenz von der Benutzerin richtig wiedergegeben wurde, soll eine neue Zufallszahl (zwischen 0 und 3) erzeugt werden und in der ArrayList hinzugef\u00fcgt werden. Danach soll wieder bei Schritt 1 gestartet werden. Falls die Sequenz von der Benutzerin nicht richtig wiedergegeben wurde, soll die L\u00e4nge der richtig gespielten Buttons \u00fcber ein Extra an eine GameOverActivity (\u00dcbung 4) \u00fcbergeben werden. Hinweis 1 Eine einfache M\u00f6glichkeit um eine ArrayList<Integer> in ein int[] Array zu \u00fcberf\u00fchren ist \u00fcber eine Schleife, wie im folgenden Snippet demonstriert: ArrayList<Integer> list = new ArrayList<>(); // ... Eintr\u00e4ge hinzuf\u00fcgen int sequence[] = new int[list.size()]; for (int i = 0; i < sequence.length; i++) { sequence[i] = list.get(i); } Hinweis 2 Buttons k\u00f6nnen \u00fcber die Methode setEnabled aktiviert oder deaktiviert werden. Hinweis 3 Auf das Ende der Animationssequenz des AnimatorSet kann \u00fcber einen Listener reagiert werden ( Dokumentation ).","title":"\u00dcbung 3 (3h)"},{"location":"%C3%BCbungen/02/#ubung-4-2h","text":"Es sollen 2 weitere Activities eingef\u00fchrt werden und die aktuelle MainActivity soll zu einer GameActivity refactored werden: Es soll eine neue MainActivity geben, welche 2 Buttons enth\u00e4lt, welche das Spiel entweder im Normalen Modus oder im Schnellen Modus starten k\u00f6nnen. \u00dcber ein Extra im Intent sollen unterschiedliche Werte f\u00fcr die Duration der Animationen \u00fcbergeben werden (eine schnelle und eine normale Variante). Die GameActivity soll das Spiel enthalten, also alles was von \u00dcbung 0 bis \u00dcbung 3 implementiert wurde. Die GameOverActivity soll die Anzahl der richtig gespielten Buttons anzeigen.","title":"\u00dcbung 4 (2h)"},{"location":"%C3%BCbungen/02/#ubung-5-1h","text":"F\u00fcr die 3 Buttons ( Normal Mode , Fast Mode und Restart ), die Textfelder und den Hintergrund sollen jeweils Variablen f\u00fcr die Farben bzw. Styles erstellt werden. Die Styles bzw. Farbvariablen sollen entsprechend mit den UI-Elementen verkn\u00fcpft werden. Folgend findet sich eine beispielhafte Angabe der Styles: <style name= \"Theme.SimonGame.GameButton\" parent= \"Widget.MaterialComponents.Button\" > <!-- items --> </style> <style name= \"Theme.SimonGame.GameText\" parent= \"Widget.MaterialComponents.TextView\" > <!-- items --> </style>","title":"\u00dcbung 5 (1h)"},{"location":"%C3%BCbungen/02/#ubung-6-1h","text":"F\u00fcr das Spiel soll es m\u00f6glich sein, dass zwischen einem normalen und einem dunklen Design gewechselt werden kann. Jenachdem welche Systemeinstellung die Benutzerin trifft, soll sich auch die App anpassen. Die entsprechenden Farbwerte, welche in \u00dcbung 5 definiert wurden, sollten \u00fcber den night Qualifier \u00fcberladen werden. Das rechte Bild zeigt das Spiel im normalen Design.","title":"\u00dcbung 6 (1h)"},{"location":"%C3%BCbungen/03/","text":"\u00dcbungsblatt 3 \u00dcbung 0 In der \u00dcbung 0 soll gemeinsam die Grundlage f\u00fcr die App Task Master entwickelt werden. Es sollen \u00fcber das Room Framework eigene Tasks verwaltet werden k\u00f6nnen. Ein Task soll dabei folgenden Aufbau haben: @Entity class Task { @PrimaryKey ( autoGenerate = true ) public int id ; public String title ; public int priority ; public Date dueDate ; } \u00dcbung 1 (1h) Es sollen einige kosmetische \u00c4nderungen vorgenommen werden: Zwischen den einzelnen Listenelementen sollen Trennlinien erstellt werden. Dazu k\u00f6nnen sog. Dekoratoren ( ItemDecoration ) f\u00fcr die RecyclerView verwendet werden. \u00dcber die Methode addItemDecoration kann eine Instanz der Klasse DividerItemDecoration \u00fcbergeben werden. Es soll ein FloatingActionButton am rechten unteren Rand hinzugef\u00fcgt werden. Bei Klick auf diesen Button soll eine neue Activity ( ManageTaskActivity ) ge\u00f6ffnet werden. Der FloatingActionButton soll mit einem Icon ausgestattet werden. Suchen Sie dazu ein passendes SVG Icon im Internet (zB Ionicons , FontAwesome , Feather Icons ). Im Android Studio kann das SVG-Icon \u00fcber File > New > Vector Asset als Drawable im Projekt hinzugef\u00fcgt werden. \u00dcbung 2 (1h) Das Erscheinungsbild der Activity ManageTaskActivity soll entsprechend gestaltet werden. Im ersten Schritt sollen die Formularfelder erstellt werden. Jedes Formularfeld hat links oben eine TextView als Label positioniert. Folgende Formularfelder kommen zum Einsatz: F\u00fcr den Titel des Tasks soll ein EditText zum Einsatz kommen. F\u00fcr die Auswahl des Datums soll ein DatePicker verwendet werden. Dabei sollen die Attribute datePickerMode als spinner und calendarViewShown als false gesetzt werden. F\u00fcr die Auswahl der Priorit\u00e4t soll ein Spinner im spinnerMode dialog verwendet werden. Die Eintr\u00e4ge im Spinner k\u00f6nnen \u00fcber das Attribut entries gesetzt werden. Dazu muss ein string-array als Resource Type Values angelegt werden und mit dem Spinner verkn\u00fcpft werden. \u00dcbung 3 (1h) Im n\u00e4chsten Schritt soll die ActionBar der ManageTaskActivity noch entsprechend angepasst werden: Im Manifest soll f\u00fcr die Activity als parentActivityName die MainActivity eingetragen werden. Dies erzeugt den Zur\u00fcckbutton in der ActionBar . Rechts in der ActionBar soll ein Button zum Speichern erzeugt werden. Hierf\u00fcr soll wiederum ein passendes SVG Icon ausgew\u00e4hlt werden und als Vector Asset importiert werden. Um den Button zu erzeugen, muss eine Men\u00fc-Ressource erstellt werden. Dies wird mit Rechtsklick auf den res Ordner und der Auswahl New Resource File erstellt. Als Resource Type soll Menu ausgew\u00e4hlt werden. Im <menu> XML-Element muss ein entsprechendes <item> hinzugef\u00fcgt werden (Icon muss ausgew\u00e4hlt werden und showAsAction soll auf always gesetzt werden). Die Vorschaut kann in Android Studio genutzt werden, \u00e4hnlich wie bei der Erstellung von Layouts. In der ManageTaskActivity muss nun die Methode onCreateOptionsMenu \u00fcberschrieben werden und das Men\u00fc \"Inflated\" werden. \u00dcber die Methode getMenuInflator kann eine Instanz der Klasse MenuInflator abgefragt werden, dieser besitzt die Methode inflate , welche genutzt werden soll. \u00dcbung 4 (2h) Mit Klick auf den Button zum Speichern in der ManageTaskActivity soll ein neues Task Objekt erzeugt werden und dieses \u00fcber das entsprechende DAO gespeichert werden. Der Klick auf den Button in der ActionBar kann \u00fcber die Implementierung der Methode onOptionsItemSelected abgefangen werden. Nach dem Speichern soll die MainActivity gestartet werden und der neue Task sollte dort sichtbar sein. \u00dcbung 5 (2h) Innerhalb der MainActivity soll es m\u00f6glich sein, dass auf einen Listeneintrag geklickt wird. Ein Klick soll dabei die ManageTaskActivity \u00f6ffnen und den Listeneintrag zum editieren anzeigen. Damit die ManageTaskActivity entscheiden kann, ob sie im Create oder Update Modus ist soll die id des Tasks innerhalb des Intents mitgegeben werden. Im Update Modus sollen die Formularfelder die Inhalte des Tasks laden und zum editieren bereitstellen. Bei Klick auf Speichern soll der Task in der Datenbank \u00fcberschrieben ( Update ) werden. \u00dcbung 6 (3h) Mit einer Swipe Geste nach Links sollen Eintr\u00e4ge aus der Liste in der MainActivity entfernt werden k\u00f6nnen. Dazu kann die Klasse ItemTouchHelper verwendet werden. Mit einem Callback (hier SimpleCallback ) kann das bewegen eines Listen Eintrags bewerkstelligt werden. ItemTouchHelper touchHelper = new ItemTouchHelper ( new ItemTouchHelper . SimpleCallback ( ItemTouchHelper . LEFT , ItemTouchHelper . LEFT ) { @Override public boolean onMove ( @NonNull RecyclerView recyclerView , @NonNull RecyclerView . ViewHolder viewHolder , @NonNull RecyclerView . ViewHolder target ) { return false ; } @Override public void onSwiped ( @NonNull RecyclerView . ViewHolder viewHolder , int direction ) { // Position in der Datenquelle abfragen int position = viewHolder . getAdapterPosition (); // l\u00f6schen durchf\u00fchren, dazu muss im Adapter eine L\u00f6schen Operation implementiert werden // Nachdem L\u00f6schen in der Datenbank m\u00fcssen die Daten im Adapter neu geladen werden // ansonsten laden sich die Eintr\u00e4ge in der RecyclerView nicht neu, nachdem Neuladen // muss im Adapter die Methode notifyDataSetChanged(); aufgerufen werden } }); // Instanz der RecyclerView \u00fcbergeben touchHelper . attachToRecyclerView (...); Mittels einer Snackbar soll am unteren Bildschirmrand angezeigt werden, dass der Eintrag entfernt wurde.","title":"\u00dcbungsblatt 3"},{"location":"%C3%BCbungen/03/#ubungsblatt-3","text":"","title":"\u00dcbungsblatt 3"},{"location":"%C3%BCbungen/03/#ubung-0","text":"In der \u00dcbung 0 soll gemeinsam die Grundlage f\u00fcr die App Task Master entwickelt werden. Es sollen \u00fcber das Room Framework eigene Tasks verwaltet werden k\u00f6nnen. Ein Task soll dabei folgenden Aufbau haben: @Entity class Task { @PrimaryKey ( autoGenerate = true ) public int id ; public String title ; public int priority ; public Date dueDate ; }","title":"\u00dcbung 0"},{"location":"%C3%BCbungen/03/#ubung-1-1h","text":"Es sollen einige kosmetische \u00c4nderungen vorgenommen werden: Zwischen den einzelnen Listenelementen sollen Trennlinien erstellt werden. Dazu k\u00f6nnen sog. Dekoratoren ( ItemDecoration ) f\u00fcr die RecyclerView verwendet werden. \u00dcber die Methode addItemDecoration kann eine Instanz der Klasse DividerItemDecoration \u00fcbergeben werden. Es soll ein FloatingActionButton am rechten unteren Rand hinzugef\u00fcgt werden. Bei Klick auf diesen Button soll eine neue Activity ( ManageTaskActivity ) ge\u00f6ffnet werden. Der FloatingActionButton soll mit einem Icon ausgestattet werden. Suchen Sie dazu ein passendes SVG Icon im Internet (zB Ionicons , FontAwesome , Feather Icons ). Im Android Studio kann das SVG-Icon \u00fcber File > New > Vector Asset als Drawable im Projekt hinzugef\u00fcgt werden.","title":"\u00dcbung 1 (1h)"},{"location":"%C3%BCbungen/03/#ubung-2-1h","text":"Das Erscheinungsbild der Activity ManageTaskActivity soll entsprechend gestaltet werden. Im ersten Schritt sollen die Formularfelder erstellt werden. Jedes Formularfeld hat links oben eine TextView als Label positioniert. Folgende Formularfelder kommen zum Einsatz: F\u00fcr den Titel des Tasks soll ein EditText zum Einsatz kommen. F\u00fcr die Auswahl des Datums soll ein DatePicker verwendet werden. Dabei sollen die Attribute datePickerMode als spinner und calendarViewShown als false gesetzt werden. F\u00fcr die Auswahl der Priorit\u00e4t soll ein Spinner im spinnerMode dialog verwendet werden. Die Eintr\u00e4ge im Spinner k\u00f6nnen \u00fcber das Attribut entries gesetzt werden. Dazu muss ein string-array als Resource Type Values angelegt werden und mit dem Spinner verkn\u00fcpft werden.","title":"\u00dcbung 2 (1h)"},{"location":"%C3%BCbungen/03/#ubung-3-1h","text":"Im n\u00e4chsten Schritt soll die ActionBar der ManageTaskActivity noch entsprechend angepasst werden: Im Manifest soll f\u00fcr die Activity als parentActivityName die MainActivity eingetragen werden. Dies erzeugt den Zur\u00fcckbutton in der ActionBar . Rechts in der ActionBar soll ein Button zum Speichern erzeugt werden. Hierf\u00fcr soll wiederum ein passendes SVG Icon ausgew\u00e4hlt werden und als Vector Asset importiert werden. Um den Button zu erzeugen, muss eine Men\u00fc-Ressource erstellt werden. Dies wird mit Rechtsklick auf den res Ordner und der Auswahl New Resource File erstellt. Als Resource Type soll Menu ausgew\u00e4hlt werden. Im <menu> XML-Element muss ein entsprechendes <item> hinzugef\u00fcgt werden (Icon muss ausgew\u00e4hlt werden und showAsAction soll auf always gesetzt werden). Die Vorschaut kann in Android Studio genutzt werden, \u00e4hnlich wie bei der Erstellung von Layouts. In der ManageTaskActivity muss nun die Methode onCreateOptionsMenu \u00fcberschrieben werden und das Men\u00fc \"Inflated\" werden. \u00dcber die Methode getMenuInflator kann eine Instanz der Klasse MenuInflator abgefragt werden, dieser besitzt die Methode inflate , welche genutzt werden soll.","title":"\u00dcbung 3 (1h)"},{"location":"%C3%BCbungen/03/#ubung-4-2h","text":"Mit Klick auf den Button zum Speichern in der ManageTaskActivity soll ein neues Task Objekt erzeugt werden und dieses \u00fcber das entsprechende DAO gespeichert werden. Der Klick auf den Button in der ActionBar kann \u00fcber die Implementierung der Methode onOptionsItemSelected abgefangen werden. Nach dem Speichern soll die MainActivity gestartet werden und der neue Task sollte dort sichtbar sein.","title":"\u00dcbung 4 (2h)"},{"location":"%C3%BCbungen/03/#ubung-5-2h","text":"Innerhalb der MainActivity soll es m\u00f6glich sein, dass auf einen Listeneintrag geklickt wird. Ein Klick soll dabei die ManageTaskActivity \u00f6ffnen und den Listeneintrag zum editieren anzeigen. Damit die ManageTaskActivity entscheiden kann, ob sie im Create oder Update Modus ist soll die id des Tasks innerhalb des Intents mitgegeben werden. Im Update Modus sollen die Formularfelder die Inhalte des Tasks laden und zum editieren bereitstellen. Bei Klick auf Speichern soll der Task in der Datenbank \u00fcberschrieben ( Update ) werden.","title":"\u00dcbung 5 (2h)"},{"location":"%C3%BCbungen/03/#ubung-6-3h","text":"Mit einer Swipe Geste nach Links sollen Eintr\u00e4ge aus der Liste in der MainActivity entfernt werden k\u00f6nnen. Dazu kann die Klasse ItemTouchHelper verwendet werden. Mit einem Callback (hier SimpleCallback ) kann das bewegen eines Listen Eintrags bewerkstelligt werden. ItemTouchHelper touchHelper = new ItemTouchHelper ( new ItemTouchHelper . SimpleCallback ( ItemTouchHelper . LEFT , ItemTouchHelper . LEFT ) { @Override public boolean onMove ( @NonNull RecyclerView recyclerView , @NonNull RecyclerView . ViewHolder viewHolder , @NonNull RecyclerView . ViewHolder target ) { return false ; } @Override public void onSwiped ( @NonNull RecyclerView . ViewHolder viewHolder , int direction ) { // Position in der Datenquelle abfragen int position = viewHolder . getAdapterPosition (); // l\u00f6schen durchf\u00fchren, dazu muss im Adapter eine L\u00f6schen Operation implementiert werden // Nachdem L\u00f6schen in der Datenbank m\u00fcssen die Daten im Adapter neu geladen werden // ansonsten laden sich die Eintr\u00e4ge in der RecyclerView nicht neu, nachdem Neuladen // muss im Adapter die Methode notifyDataSetChanged(); aufgerufen werden } }); // Instanz der RecyclerView \u00fcbergeben touchHelper . attachToRecyclerView (...); Mittels einer Snackbar soll am unteren Bildschirmrand angezeigt werden, dass der Eintrag entfernt wurde.","title":"\u00dcbung 6 (3h)"}]}